{{- $gName := include "Generated.fullname" .}}
{{- $gChart := include "Generated.chart" . }}
{{- $gReleaseName := .Release.Name }}
{{- $gHeritage := .Release.Service }}
{{- $mainScope := . }}
{{- $version := .Values.image.tag }}
{{- range $job :=.Values.cronJob }}
---
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: {{ $gName }}-{{ $job.name }}
  labels:
    app: {{ $gName }}
    chart: {{ $gChart }}
    release: {{ $gReleaseName }}
    heritage: {{ $gHeritage }}
    version: {{ $version | default "0" | quote }}
spec:
  {{- if $job.interpolate }}
  schedule: {{ $job.spec.schedule | quote }}
  concurrencyPolicy: {{ default "Forbid" $job.spec.concurrencyPolicy }}
  successfulJobsHistoryLimit: {{ default 1 $job.spec.successfulJobsHistoryLimit }}
  failedJobsHistoryLimit: {{ default 1 $job.spec.failedJobsHistoryLimit }}

  jobTemplate:
    spec:
      backoffLimit: {{ default 2 $job.spec.jobTemplate.spec.backoffLimit }}
      template:
        metadata:
          annotations:
            sidecar.istio.io/inject: "false"
        spec:
          restartPolicy: {{ default "Never" $job.spec.jobTemplate.spec.template.spec.restartPolicy }}
          activeDeadlineSeconds: {{ default 600 $job.spec.jobTemplate.spec.template.spec.activeDeadlineSeconds }}
          containers:
            {{- range $container := $job.spec.jobTemplate.spec.template.spec.containers }}
            - name: {{ $gName }}-{{ $container.name }}
              image: {{ tpl $container.image $mainScope }}:{{ tpl $container.tag $mainScope }}
              args:
              {{- range $container.args }}
                - {{ . }}
              {{- end }}
              command:
              {{- range $container.command }}
                - {{ . }}
              {{- end }}

              {{- if or $mainScope.Values.env $mainScope.Values.envSecrets $mainScope.Values.envConfigurations }}
              env:
                {{- range $key, $value := $mainScope.Values.env }}
                - name: "{{ $key }}"
                  value: "{{ $value }}"
                {{- end }}
                {{- range $key, $secret := $mainScope.Values.envSecrets }}
                - name: {{ $key }}
                  valueFrom:
                    secretKeyRef:
                      name: {{ $secret }}
                      key: {{ $key | quote }}
                {{- end }}
                {{- range $key, $config := $mainScope.Values.envConfigurations }}
                - name: {{ $key }}
                  valueFrom:
                    configMapKeyRef:
                      name: {{ $config }}
                      key: {{ $key | quote }}
                {{- end }}
              {{- end }}

              volumeMounts:
              {{- if $mainScope.Values.mountSecret }}
              - name: pv-secret
                mountPath: "/var/secret"
                readOnly: true
              {{- end }}
              {{- range $persist := $mainScope.Values.persistence }}
              - name: {{ $persist.name }}
                mountPath: {{ $persist.mountPath }}
              {{- end }}

              command:
              - "/bin/sh"
              - "-c"
              - |
                AWS_ACCOUNT={{ $mainScope.Values.env.account }}
                AWS_REGION={{ $mainScope.Values.env.region }}
                echo "AWS_ACCOUNT=$AWS_ACCOUNT"
                echo "AWS_REGION=$AWS_REGION"

                aws configure set aws_access_key_id $($mainScope.Values.env.accessKeyId)
                aws configure set aws_secret_access_key $($mainScope.Values.env.secretAccessKey)

                DOCKER_REGISTRY_SERVER=https://${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com
                DOCKER_USER=AWS
                DOCKER_PASSWORD=$(aws ecr get-login-password --region ${AWS_REGION})
                echo "DOCKER_REGISTRY_SERVER=$DOCKER_REGISTRY_SERVER"
                echo "DOCKER_USER=$DOCKER_USER"
                echo "DOCKER_PASSWORD=$DOCKER_PASSWORD"a
                {{ range $mainScope.Values.namespace }}
                  kubectl delete secret --namespace {{ . }} aws-registry --ignore-not-found=true
                  kubectl create secret --namespace {{ . }} docker-registry aws-registry \
                  --docker-server=$DOCKER_REGISTRY_SERVER \
                  --docker-username=$DOCKER_USER \
                  --docker-password=$DOCKER_PASSWORD \
                  --docker-email=no@email.local
                {{ end }}
                kubectl patch serviceaccount {{ $mainScope.Values.serviceAccount.name }} -p '{"imagePullSecrets":[{"name":"aws-registry"}]}'
            {{- end }}

          volumes:
          {{- if $mainScope.Values.mountSecret }}
          - name: pv-secret
            {{- range $value := $mainScope.Values.mountSecret }}
            secret:
              secretName: {{ $value }}
            {{- end }}
          {{- end }}
          {{- range $persist := $mainScope.Values.persistence }}
          - name: {{ $persist.name }}
            persistentVolumeClaim:
              claimName: {{ $gName }}-{{ $persist.name }}
          {{- end }}

  {{- else }}
{{ toYaml $job.spec | indent 2 }}
  {{- end }}
{{- end }}
